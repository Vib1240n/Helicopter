package org.csc133.a1;

import static com.codename1.ui.CN.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import javax.print.attribute.standard.DialogTypeSelection;

import com.codename1.charts.util.ColorUtil;
import com.codename1.system.Lifecycle;
import com.codename1.ui.*;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.geom.Point;
import com.codename1.ui.layouts.*;
import com.codename1.io.*;
import com.codename1.ui.plaf.*;
import com.codename1.ui.util.Resources;
import com.codename1.ui.util.UITimer;

/**
 * This file was generated by <a href="https://www.codenameone.com/">Codename
 * One</a> for the purpose
 * of building native mobile applications using Java.
 */
public class AppMain extends Lifecycle {
    private Form current;

    @Override
    public void runApp() {
    }

    public void start() {
        if (current != null) {
            current.show();
            return;
        }
        new Game().show();
    }

    public void stop() {
        current = getCurrentForm();
        if (current instanceof Dialog) {
            ((Dialog) current).dispose();
            current = getCurrentForm();
        }
    }

}

class Game extends Form implements Runnable {

    private gameWorld world;
    private int tick;
    private int return_tick;
    UITimer timer;
    final static int Disp_H = Display.getInstance().getDisplayHeight();
    final static int Disp_W = Display.getInstance().getDisplayWidth();
    static Font font = Font.createSystemFont(Font.FACE_SYSTEM,
            Font.STYLE_PLAIN, Font.SIZE_MEDIUM);
    
    public static int getMin_disp(){
        return Math.min(Disp_H, Disp_W);
    }
    
    public static int getMax_disp(){
        return Math.max(Disp_H, Disp_W);
    }
    
    
    public void paint(Graphics g) {
        super.paint(g);
        g.setColor(ColorUtil.BLACK);
        g.fillRect(0, 0, Game.Disp_W, Game.Disp_H);
        world.draw(g);
    }
    
    
    @Override
    public void run() {
        // TODO Auto-generated method stub
        return_tick = Tick();
        world.updateTick(return_tick);
        repaint();
    }
    public Game() {
        world = new gameWorld();
        tick = 0;
        timer = new UITimer(this);
        timer.schedule(100, true, this);
        addKeyListener('Q', (evt) -> world.quit());
        addKeyListener(-93, (evt) -> Helicopter.movement(-93));
        addKeyListener(-94, (evt) -> Helicopter.movement(-94));
        addKeyListener(-91, (evt) -> Helicopter.movement(-91));
        addKeyListener(-92, (evt) -> Helicopter.movement(-92));
        addKeyListener('d', (evt) -> Helicopter.fillTank());
    }
    public int Tick(){
        tick++;
        return tick;
    }

    
}
class Helicopter extends HeliPad {
    static Point location;
    River river;
    static Point river_location;
    private static int heli_radius;
    private int heli_size;
    private static int speed;
    private static double angle;
    private static int endX;
    private static int endY;
    private static int startX;
    private static int startY;
    private static int water_tank;
    private static boolean isColliding;


    public Helicopter(){
        water_tank = 0;
        isColliding = false;
        river = new River();
        river_location = river.getLocation();
        location = centerLocation;
        heli_size = 35;
        heli_radius = heli_size / 2;
        angle = Math.toRadians(90);
        endX = location.getX();
        endY = location.getY() + heli_radius*3 ;
        startX = location.getX();
        startY = location.getY();
    }
    
    public static void movement(int input){
        /*
        movements
        */
        switch(input){
            case -92 /* back */:
                if(speed > 0){
                    speed--;
                }
                break;
            case -91 /*Forward */:
                if (speed < 10) {
                    speed++;
                }
                break;
            case -93 /*Left*/:
                angle += Math.toRadians(15);
                endX= (int)(endX + Math.cos(angle));
                endY = (int) (endY - Math.sin(angle));
                break;
            case -94 /*Right */:
                angle -= Math.toRadians(15);
                endY = (int)(endX - Math.sin(angle));
                endX = (int) (endY + Math.cos(angle));
                break;
            default: 
                
        }

    }
    public static void updateForward(){
        location.setX((int)(location.getX() + Math.cos(angle) * speed));
        location.setY((int)(location.getY() - Math.sin(angle) * speed));
        startX = location.getX();
        startY = location.getY();
        endY = (int)(location.getY() - Math.sin(angle));
        endX = (int)(location.getX() + Math.cos(angle) + heli_radius * 3);
    }

    public void draw(Graphics g) {
        
        g.setFont(Game.font);
        g.setColor(ColorUtil.YELLOW);
        g.fillArc(startX - heli_radius, startY- heli_radius, heli_size, heli_size, 0, 360);
        g.drawString(""+speed , startX+15, startY+15);
        g.drawString(""+water_tank, startX + 25, startY + 25);
        g.setColor(ColorUtil.CYAN);
        g.drawLine(startX, startY, 
                endX, endY);
    }
    public static void isCollison(){
        if((startX < river_location.getX() && startY < river_location.getY()) &&(startX > Game.Disp_W*2 + river_location.getX() && startY > Game.Disp_H / 8 + river_location.getY())){
            isColliding = true;
        }
    }
    public static void fillTank(){
        if (isColliding == true && water_tank <= 1000) {
            water_tank += 100;
        }
    }
}

class gameWorld {

    Helicopter heli;
    Point location_left;
    Point location_right;
    Point location_center;
    HeliPad pad;
    River river;
    Fire fire_center;
    Fire fire_right;
    Fire fire_left;
    private Random random = new Random();
    private int rand;
    private ArrayList<Fire> fires;
    private int fire_size_center;
    private int fire_size_left;
    private int fire_size_right;

    public gameWorld() {
        /**
         * Initiliazing variables
         */
        heli = new Helicopter();
        pad = new HeliPad();
        river = new River();
        rand = random.nextInt(500)/150;
        /*
        Fire Locations
         */
        location_left = new Point(rand + Game.Disp_W / 5, rand + Game.Disp_H / 4 - Game.Disp_H / 4);
        location_right = new Point(rand + Game.Disp_W, rand + Game.Disp_H / 2 - Game.Disp_W - 2);
        location_center = new Point(rand + Game.Disp_W, rand + Game.Disp_H/2);
        /**
         * Fire Sizes
         */
        fire_size_center = random.nextInt(500) + 300;
        fire_size_left = random.nextInt(200) + 100;
        fire_size_right = random.nextInt(500) + 200;
        /**
         * Fires on the screen; class objects
         */
        // fire_center = new Fire(fire_size_center, location_center);
        // fire_left = new Fire(fire_size_left, location_left);
        // fire_right = new Fire(fire_size_right, location_right);
        fires = new ArrayList<>();
        /**
         * Adding fire locations and sizes into fire class objects 
         */
        fires.add(new Fire(fire_size_center, location_center));
        fires.add(new Fire(fire_size_left, location_left));
        fires.add(new Fire(fire_size_right, location_right));

    }

    /**
     * 
     * @param g
     */
    public void draw(Graphics g) {
        heli.draw(g);
        pad.draw(g);
        river.draw(g);  
        for(Fire fire: fires){
            fire.draw(g);
        }      
    }

    public void quit(){
        Display.getInstance().exitApplication();
    }

    public void updateTick(int timer){
        Helicopter.updateForward();
        if(timer%2 == 0){
            fire_center.grow_fire();
            fire_left.grow_fire();
            fire_right.grow_fire();
        }
        Helicopter.isCollison();
    }

}



class Fire {
    Point Location;
    private int fire_size;
    public Fire(){
    }

    public Fire(int fire_size, Point p){
        Location = p;
        this.fire_size = fire_size;

    }

    public void grow_fire(){
        if(fire_size < 470){
            fire_size += new Random().nextInt(5);
        }
    }
    public void draw(Graphics g) {
        g.setColor(ColorUtil.MAGENTA);
        g.fillArc(Location.getX(), Location.getY(), fire_size, fire_size, 0, 360);
        g.setFont(Game.font);
        g.drawString(""+fire_size, Location.getX()+fire_size + 10, Location.getY()+ fire_size + 5);
        // g.drawString("" + Location.getX(), Location.getX() + fire_size + 10, Location.getY() + fire_size + 30);
        // g.drawString("" + Location.getY(), Location.getX() + fire_size + 10, Location.getY() + fire_size + 30);
    
    } 
}


class HeliPad {
    Point location;
    static Point centerLocation;
    private int boxSize;
    private int padSize;
    private int radius;
    public HeliPad(){
        boxSize = 200;
        padSize = 150;
        radius = padSize / 2;
        location = new Point((Game.Disp_W / 2) - 100, (Game.getMin_disp() / 2) + 700);
        centerLocation = new Point(location.getX() + boxSize /2 , location.getY() + boxSize /2);
    }
    public Point getCenter(){
        return centerLocation;
    }
    public void draw(Graphics g) {
        /*
            Helipad border design
        */
        g.setColor(ColorUtil.GRAY);
        g.drawRect(location.getX(), location.getY(),
                200, 200);
        /*
            Helipad inner circle design 
         */
        g.setColor(ColorUtil.GRAY);
        g.drawArc(centerLocation.getX() - radius, centerLocation.getY() - radius, padSize, padSize, 0, 360);
    }

}

class River {
    Point Location;  
    
    public River(){
        Location = new Point(-100, Game.Disp_W/8);
    }

    public Point getLocation(){
        return Location;
    }
    public int get_river_width(){
        return -100;
    }

    public int get_river_height(){
        return Game.Disp_W/8;
    }

    public void draw(Graphics g) {

        g.setColor(ColorUtil.BLUE);
        g.drawRect(Location.getX(), Location.getY(), 
        Game.Disp_W*2 , Game.Disp_H / 8);
    }

}

//