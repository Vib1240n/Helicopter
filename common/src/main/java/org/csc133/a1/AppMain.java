package org.csc133.a1;

import static com.codename1.ui.CN.*;

import java.util.ArrayList;
import java.util.List;

import javax.print.attribute.standard.DialogTypeSelection;

import com.codename1.charts.util.ColorUtil;
import com.codename1.system.Lifecycle;
import com.codename1.ui.*;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.geom.Point;
import com.codename1.ui.layouts.*;
import com.codename1.io.*;
import com.codename1.ui.plaf.*;
import com.codename1.ui.util.Resources;
import com.codename1.ui.util.UITimer;

/**
 * This file was generated by <a href="https://www.codenameone.com/">Codename
 * One</a> for the purpose
 * of building native mobile applications using Java.
 */
public class AppMain extends Lifecycle {
    private Form current;

    @Override
    public void runApp() {
    }

    public void start() {
        if (current != null) {
            current.show();
            return;
        }
        new Game().show();
    }

    public void stop() {
        current = getCurrentForm();
        if (current instanceof Dialog) {
            ((Dialog) current).dispose();
            current = getCurrentForm();
        }
    }

}

class Game extends Form implements Runnable {

    private gameWorld world;
    final static int Disp_H = Display.getInstance().getDisplayHeight();
    final static int Disp_W = Display.getInstance().getDisplayWidth();
    
    public static int getMin_disp(){
        return Math.min(Disp_H, Disp_W);
    }
    
    public static int getMax_disp(){
        return Math.max(Disp_H, Disp_W);
    }
    
    
    public void paint(Graphics g) {
        super.paint(g);
        g.setColor(ColorUtil.BLACK);
        g.fillRect(0, 0, Game.Disp_W, Game.Disp_H);
        world.draw(g);
    }
    
    @Override
    public void run() {
        // TODO Auto-generated method stub
        
    }
    public Game() {
        world = new gameWorld();
        UITimer timer = new UITimer(this);
        timer.schedule(100, true, this);
        addKeyListener('Q', (evt) -> world.quit());
        addKeyListener(-93, (evt) -> Helicopter.movement(-93));
        addKeyListener(-94, (evt) -> Helicopter.movement(-94));
        addKeyListener(-91, (evt) -> Helicopter.movement(-91));
        addKeyListener(-92, (evt) -> Helicopter.movement(-92));
        

    }
    
}
class Helicopter extends HeliPad {
    static Point location;
    private static int heli_radius;
    private int heli_size;
    private static int speed;
    private static int angle;
    private static int endX;
    private static int endY;
    private static int startX;
    private static int startY;


    public Helicopter(){
        location = new Point(Game.Disp_W/2, Game.Disp_H/2);
        heli_size = 35;
        heli_radius = heli_size / 2;
        angle = (int) Math.toRadians(90);
        endX = centerLocation.getX();
        endY = centerLocation.getY() - heli_radius*3 ;
        startX = centerLocation.getX();
        startY = centerLocation.getY();
    }
    public static void movement(int input){
        /*
        movements
        */
        switch(input){
            case -92 /* back */:
                if(speed > 10){
                    speed--;
                }
            case -91:
                if (speed < 10) {
                    speed++;
                }
            case -93 /*Left*/:
                angle += Math.toRadians(15);
                endX= (int)(centerLocation.getX() + Math.sin(angle)+ heli_radius *3);
                endY = (int) (centerLocation.getY() - Math.cos(angle) + heli_radius * 3);
            case -94 /*Right */:
                angle -= Math.toRadians(15);
                endY = (int)(centerLocation.getY() - Math.cos(angle) + heli_radius *3);
                endX = (int) (centerLocation.getX() + Math.sin(angle) + heli_radius * 3);
            default: 
                
        }

    }
    public static void updateForward(){
        centerLocation.setX((int)(centerLocation.getX() + Math.cos(angle) * speed));
        centerLocation.setY((int)(centerLocation.getY() - Math.cos(angle) * speed));
        startX = centerLocation.getX();
        startY = centerLocation.getY();
        endY = (int)(centerLocation.getY() - Math.cos(angle) + heli_radius * 3);
        endX = (int)(centerLocation.getX() + Math.sin(angle) + heli_radius * 3);
    }

    public void draw(Graphics g) {

        g.setColor(ColorUtil.YELLOW);
        g.fillArc(centerLocation.getX() - heli_radius, centerLocation.getY() - heli_radius, heli_size, heli_size, 0, 360);
        
        g.setColor(ColorUtil.CYAN);
        g.drawLine(startX, startY, 
                endX, endY);
    }
}

class gameWorld {

    Helicopter heli;
    HeliPad pad;
    River river;
    Fire fire;

    public gameWorld() {
        heli = new Helicopter();
        pad = new HeliPad();
        river = new River();
        fire = new Fire();
    }

    public void draw(Graphics g) {
        heli.draw(g);
        pad.draw(g);
        river.draw(g);
        fire.draw(g);        

    }

    public void quit(){
        Display.getInstance().exitApplication();
    }
    public void updateTick(){
        Helicopter.updateForward();;
    }

}



class Fire {
    Point Location;

    public Fire(){
        Location = new Point(Game.Disp_W/2, Game.Disp_H/2);
    }

    public void draw(Graphics g) {
      //  int radius = 100;

        g.setColor(ColorUtil.MAGENTA);
      //  g.fillArc(x, y, width, height, 0, 360);

    }

    public int[] UpdateLocation(){
        int[] updateLocation = {0,0};

        return updateLocation;
    } 



}


class HeliPad {
    Point location;
    static Point centerLocation;
    private int boxSize;
    private int padSize;
    private int radius;
    public HeliPad(){
        boxSize = 200;
        padSize = 150;
        radius = padSize / 2;
        location = new Point((Game.Disp_W / 2) - 100, (Game.getMin_disp() / 2) + 700);
        centerLocation = new Point(location.getX() + boxSize /2 , location.getY() + boxSize /2);
    }
    public Point getCenter(){
        return centerLocation;
    }
    public void draw(Graphics g) {
        /*
            Helipad border design
        */
        g.setColor(ColorUtil.GRAY);
        g.drawRect(location.getX(), location.getY(),
                200, 200);
        /*
            Helipad inner circle design 
         */
        g.setColor(ColorUtil.GRAY);
        g.drawArc(centerLocation.getX() - radius, centerLocation.getY() - radius, padSize, padSize, 0, 360);
    }

}

class River {
    Point Location;     

    public void draw(Graphics g) {

        g.setColor(ColorUtil.BLUE);
        g.drawRect(-100, Game.Disp_W / 8, 
        Game.Disp_W*2 , Game.Disp_H / 8);
    }

}
